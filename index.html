<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Value Stream Map Visualizer</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Value Stream Map Editor</h1>
        </div>
        
        <div class="main-content">
            <div class="editor-panel collapsed">
                <button class="editor-toggle" title="Toggle DSL Editor">âŸ©</button>
                <div class="panel-header">
                    <div class="filename-display" id="currentFilename">
                        <span class="filename-label">File:</span>
                        <span class="filename-text">Untitled.vsm</span>
                    </div>
                    <div class="button-group">
                        <button class="editor-button" data-action="save-file">Save File</button>
                        <button class="editor-button" data-action="load-file">Load File</button>
                        <button class="editor-button" data-action="clear">New VSM</button>
                    </div>
                </div>
                <textarea id="dslEditor" class="editor" spellcheck="false">{
  "processes": {
    "ProcessA_12012026120000": {
      "stage_id": 1,
      "name": "Process A",
      "owner": "",
      "description": "New process description",
      "wait_time": "4h",
      "process_time": "1d",
      "defect_rate": "0",
      "value_type": "VA"
    },
    "ProcessB_12012026120001": {
      "stage_id": 2,
      "name": "Process B",
      "owner": "",
      "description": "New process derived from Process A",
      "wait_time": "30m",
      "process_time": "1d",
      "defect_rate": "0",
      "value_type": "VA"
    }
  },
  "flows": [
    {
      "from": "ProcessA_12012026120000",
      "to": "ProcessB_12012026120001",
      "wait_time": "0.5d",
      "value_type": "NVA"
    }
  ],
  "reworkFlows": [],
  "positions": {
    "ProcessA_12012026120000": { "x": 370, "y": 290 },
    "ProcessB_12012026120001": { "x": 630, "y": 290 }
  }
}</textarea>
                <button class="parse-button" onclick="parseAndVisualize()">Parse & Visualize</button>
                <input type="file" id="fileInput" accept=".vsm" style="display: none;">
            </div>
            <div class="pane-splitter" id="paneSplitter"></div>
            <div class="visualization-panel">
                <div class="canvas-container">
                    <svg id="vsmCanvas" width="900" height="700"></svg>
                </div>
            </div>
        </div>

        <div class="totals-strip">
            <div class="total-item clickable" id="leadTimeItem">
                <div class="total-label">Total Lead Time</div>
                <div class="total-value" id="totalLeadTime">-</div>
            </div>
            <div class="total-item clickable" id="waitTimeItem">
                <div class="total-label">Total Wait Time</div>
                <div class="total-value" id="totalWaitTime">-</div>
            </div>
            <div class="total-item clickable" id="processTimeItem">
                <div class="total-label">Total Process Time</div>
                <div class="total-value" id="totalProcessTime">-</div>
            </div>
            <div class="total-item clickable" id="pceItem">
                <div class="total-label">PCE</div>
                <div class="total-value" id="pce">-</div>
            </div>
            <div class="total-item clickable" id="criticalPathItem">
                <div class="total-label">Critical Path</div>
                <div class="critical-path" id="criticalPath">-</div>
            </div>
        </div>

        <!-- Wait Time Breakdown Modal -->
        <div id="waitTimeModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Total Wait Time Breakdown</h3>
                    <span class="modal-close" data-modal="waitTimeModal">&times;</span>
                </div>
                <div class="modal-body" id="waitTimeBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Lead Time Breakdown Modal -->
        <div id="leadTimeModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Total Lead Time Breakdown</h3>
                    <span class="modal-close" data-modal="leadTimeModal">&times;</span>
                </div>
                <div class="modal-body" id="leadTimeBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Process Time Breakdown Modal -->
        <div id="processTimeModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Total Process Time Breakdown</h3>
                    <span class="modal-close" data-modal="processTimeModal">&times;</span>
                </div>
                <div class="modal-body" id="processTimeBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- PCE Breakdown Modal -->
        <div id="pceModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Process Cycle Efficiency (PCE)</h3>
                    <span class="modal-close" data-modal="pceModal">&times;</span>
                </div>
                <div class="modal-body" id="pceBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Critical Path Breakdown Modal -->
        <div id="criticalPathModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Critical Path Breakdown</h3>
                    <span class="modal-close" data-modal="criticalPathModal">&times;</span>
                </div>
                <div class="modal-body" id="criticalPathBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import VSMParser from './js/VSMParser.js';
        import VSMVisualizer from './js/VSMVisualizer.js';

        const parser = new VSMParser();
        let visualizer;

        // Filename state management
        let currentFilename = 'Untitled.vsm';
        let isModified = false;

        function updateFilenameDisplay() {
            const filenameElement = document.querySelector('.filename-text');
            if (filenameElement) {
                filenameElement.textContent = currentFilename;
                if (isModified) {
                    filenameElement.classList.add('modified');
                } else {
                    filenameElement.classList.remove('modified');
                }
            }
        }

        function setFilename(name) {
            currentFilename = name;
            isModified = false;
            updateFilenameDisplay();
            // Store in localStorage for persistence
            localStorage.setItem('vsmCurrentFilename', currentFilename);
        }

        function markAsModified() {
            isModified = true;
            updateFilenameDisplay();
        }

        // Load saved filename on initialization
        function loadSavedFilename() {
            const savedFilename = localStorage.getItem('vsmCurrentFilename');
            if (savedFilename) {
                currentFilename = savedFilename;
            }
            updateFilenameDisplay();
        }

        function clearVSM() {
            const now = new Date();
            const timestamp = now.getDate().toString().padStart(2, '0') +
                              (now.getMonth() + 1).toString().padStart(2, '0') +
                              now.getFullYear() +
                              now.getHours().toString().padStart(2, '0') +
                              now.getMinutes().toString().padStart(2, '0') +
                              now.getSeconds().toString().padStart(2, '0');
            const processId = `NewProcess_${timestamp}`;

            // Create default JSON with one process
            const defaultJSON = {
                processes: {
                    [processId]: {
                        stage_id: 1,
                        name: "New Process",
                        owner: "",
                        description: "New process description",
                        wait_time: "0d",
                        process_time: "0s",
                        defect_rate: "0",
                        value_type: "VA"
                    }
                },
                flows: [],
                reworkFlows: [],
                positions: {}
            };

            // Set the DSL editor
            document.getElementById('dslEditor').value = JSON.stringify(defaultJSON, null, 2);

            // Create the default process structure
            const defaultProcess = {
                attributes: {
                    stage_id: 1,
                    name: "New Process",
                    owner: "",
                    description: "New process description",
                    wait_time: "0d",
                    process_time: "0s",
                    defect_rate: "0",
                    value_type: "VA"
                }
            };

            // Reset the visualizer data with the default process
            visualizer.currentProcesses = { [processId]: defaultProcess };
            visualizer.currentFlows = [];
            visualizer.currentInfoFlows = [];

            // Position the process in the center
            const centerX = visualizer.width / 2 - visualizer.processWidth / 2;
            const centerY = visualizer.height / 2 - visualizer.processHeight / 2;
            visualizer.positions = { [processId]: { x: centerX, y: centerY } };

            // Visualize with the default process
            visualizer.visualize({
                processes: visualizer.currentProcesses,
                flows: [],
                infoFlows: [],
                positions: visualizer.positions
            });

            // Reset filename
            setFilename('Untitled.vsm');
            // Clear localStorage filename
            localStorage.removeItem('vsmCurrentFilename');
        }

        async function initializeVSM() {
            visualizer = new VSMVisualizer(document.getElementById('vsmCanvas'));
            
            // Try to load saved state first
            if (!visualizer.loadState()) {
                // If no saved state, load initial DSL
                const initialData = parser.loadInitialDSL();
                visualizer.visualize(initialData);
            }

            // Setup editor panel toggle
            const editorPanel = document.querySelector('.editor-panel');
            const toggleButton = document.querySelector('.editor-toggle');
            
            if (toggleButton) {
                toggleButton.addEventListener('click', () => {
                    editorPanel.classList.toggle('collapsed');
                    toggleButton.textContent = editorPanel.classList.contains('collapsed') ? 'âŸ©' : 'âŸ¨';
                });
            }

            // Add button click handlers
            document.querySelector('[data-action="clear"]').addEventListener('click', clearVSM);
            document.querySelector('[data-action="save-file"]').addEventListener('click', saveVSMToFile);
            document.querySelector('[data-action="load-file"]').addEventListener('click', loadVSMFromFile);

            // Track editor modifications
            document.getElementById('dslEditor').addEventListener('input', markAsModified);

            // Load saved filename on init
            loadSavedFilename();

            // Setup all breakdown modals
            setupWaitTimeModal();
            setupLeadTimeModal();
            setupProcessTimeModal();
            setupPCEModal();
            setupCriticalPathModal();
            setupModalCloseHandlers();
        }

        function parseAndVisualize() {
            const dslText = document.getElementById('dslEditor').value;
            const parsedData = parser.parse(dslText);
            
            // No time validation needed since CT is calculated as PT + WT
            
            // If validation passes, update visualization
            visualizer.visualize(parsedData);
        }

        function saveVSM() {
            if (visualizer) {
                visualizer.saveState();
            }
        }

        function addNewProcess() {
            // Generate ID from process name with timestamp
            const processName = "New Process";
            const slug = processName.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
            const now = new Date();
            const dd = String(now.getDate()).padStart(2, '0');
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const yyyy = String(now.getFullYear());
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            const ss = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${dd}${mm}${yyyy}${hh}${min}${ss}`;
            let processId = `${slug}_${timestamp}`;
            
            // Handle collisions
            if (visualizer.currentProcesses && visualizer.currentProcesses[processId]) {
                let counter = 1;
                while (visualizer.currentProcesses[`${processId}_${counter}`]) {
                    counter++;
                    if (counter > 100) break;
                }
                processId = `${processId}_${counter}`;
            }
            
            const newProcess = {
                attributes: {
                    stage_id: 1,
                    name: processName,
                    owner: "",
                    description: "New process description",
                    wait_time: "0d",
                    process_time: "0s",
                    defect_rate: "0",
                    value_type: "VA"
                }
            };

            // Add to current processes
            visualizer.currentProcesses[processId] = newProcess;

            // Calculate position for new process
            const centerX = visualizer.width / 2 - visualizer.processWidth / 2;
            const centerY = visualizer.height / 2 - visualizer.processHeight / 2;
            visualizer.positions[processId] = { x: centerX, y: centerY };

            // Update the JSON in the editor
            const dslEditor = document.getElementById('dslEditor');
            try {
                const currentData = JSON.parse(dslEditor.value);
                currentData.processes[processId] = {
                    stage_id: 1,
                    name: "New Process",
                    owner: "",
                    description: "New process description",
                    wait_time: "0d",
                    process_time: "0s",
                    defect_rate: "0",
                    value_type: "VA"
                };
                currentData.positions[processId] = { x: centerX, y: centerY };
                dslEditor.value = JSON.stringify(currentData, null, 2);
            } catch (e) {
                console.error('Error updating JSON:', e);
            }

            // Redraw the visualization
            visualizer.visualize({
                processes: visualizer.currentProcesses,
                flows: visualizer.currentFlows,
                infoFlows: visualizer.currentInfoFlows,
                positions: visualizer.positions
            });
        }

        function saveVSMToFile() {
            try {
                // Get current state from visualizer
                const currentState = {
                    processes: visualizer.currentProcesses,
                    flows: visualizer.currentFlows,
                    infoFlows: visualizer.currentInfoFlows,
                    reworkFlows: visualizer.currentReworkFlows,
                    positions: visualizer.positions
                };

                // Serialize to JSON format
                const dslContent = parser.serialize(currentState);

                // Create blob and download
                const blob = new Blob([dslContent], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                // Create temporary download link
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = currentFilename;

                // Trigger download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

                // Clean up
                URL.revokeObjectURL(url);

                // Mark as saved
                isModified = false;
                updateFilenameDisplay();

                console.log('VSM saved to file:', currentFilename);
            } catch (error) {
                console.error('Error saving VSM file:', error);
                alert('Error saving file: ' + error.message);
            }
        }

        function loadVSMFromFile() {
            const fileInput = document.getElementById('fileInput');

            // Set up the file input handler
            fileInput.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;

                // Validate file extension
                if (!file.name.endsWith('.vsm')) {
                    alert('Invalid file type. Please select a .vsm file.');
                    fileInput.value = '';
                    return;
                }

                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        const dslContent = e.target.result;

                        // Validate DSL content
                        const parsedData = parser.parse(dslContent);

                        // Basic validation: check if we have processes
                        if (!parsedData.processes || Object.keys(parsedData.processes).length === 0) {
                            throw new Error('Invalid VSM file: No processes found');
                        }

                        // Load into editor
                        document.getElementById('dslEditor').value = dslContent;

                        // Visualize the loaded data
                        visualizer.visualize(parsedData);

                        // Update filename
                        setFilename(file.name);

                        // Save to localStorage for auto-recovery
                        visualizer.saveState();

                        console.log('VSM loaded from file:', file.name);
                    } catch (error) {
                        console.error('Error loading VSM file:', error);
                        alert('Error loading file: ' + error.message + '\n\nPlease check that the file is a valid VSM DSL file.');
                    } finally {
                        // Reset file input
                        fileInput.value = '';
                    }
                };

                reader.onerror = function() {
                    alert('Error reading file. Please try again.');
                    fileInput.value = '';
                };

                reader.readAsText(file);
            };

            // Trigger file selection dialog
            fileInput.click();
        }

        function setupWaitTimeModal() {
            const modal = document.getElementById('waitTimeModal');
            const waitTimeItem = document.getElementById('waitTimeItem');

            // Open modal on click
            waitTimeItem.addEventListener('click', () => {
                showWaitTimeBreakdown();
                modal.style.display = 'block';
            });
        }

        function setupLeadTimeModal() {
            const modal = document.getElementById('leadTimeModal');
            const leadTimeItem = document.getElementById('leadTimeItem');

            // Open modal on click
            leadTimeItem.addEventListener('click', () => {
                showLeadTimeBreakdown();
                modal.style.display = 'block';
            });
        }

        function setupProcessTimeModal() {
            const modal = document.getElementById('processTimeModal');
            const processTimeItem = document.getElementById('processTimeItem');

            // Open modal on click
            processTimeItem.addEventListener('click', () => {
                showProcessTimeBreakdown();
                modal.style.display = 'block';
            });
        }

        function setupPCEModal() {
            const modal = document.getElementById('pceModal');
            const pceItem = document.getElementById('pceItem');

            // Open modal on click
            pceItem.addEventListener('click', () => {
                showPCEBreakdown();
                modal.style.display = 'block';
            });
        }

        function setupCriticalPathModal() {
            const modal = document.getElementById('criticalPathModal');
            const criticalPathItem = document.getElementById('criticalPathItem');

            // Open modal on click
            criticalPathItem.addEventListener('click', () => {
                showCriticalPathBreakdown();
                modal.style.display = 'block';
            });
        }

        // Generic modal close handlers
        function setupModalCloseHandlers() {
            // Close modal on X button click
            document.querySelectorAll('.modal-close').forEach(closeBtn => {
                closeBtn.addEventListener('click', (e) => {
                    const modalId = e.target.getAttribute('data-modal');
                    const modal = document.getElementById(modalId);
                    if (modal) {
                        modal.style.display = 'none';
                    }
                });
            });

            // Close modal on outside click
            window.addEventListener('click', (event) => {
                if (event.target.classList.contains('modal')) {
                    event.target.style.display = 'none';
                }
            });

            // Close all modals on Escape key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    document.querySelectorAll('.modal').forEach(modal => {
                        if (modal.style.display === 'block') {
                            modal.style.display = 'none';
                        }
                    });
                }
            });
        }

        function showPCEBreakdown() {
            const breakdownDiv = document.getElementById('pceBreakdown');

            if (!visualizer.criticalPathData || !visualizer.criticalPathData.path) {
                breakdownDiv.innerHTML = '<p style="color: #7f8c8d;">No critical path data available.</p>';
                return;
            }

            const criticalPath = visualizer.criticalPathData.path;
            
            // Calculate Total Process Time (critical path only)
            const totalProcessTime = criticalPath.reduce((sum, processId) => {
                const process = visualizer.currentProcesses[processId];
                if (process) {
                    return sum + visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                }
                return sum;
            }, 0);

            // Calculate Value-Adding Process Time (VA only, excludes NNVA and NVA)
            const valueAddingProcessTime = criticalPath.reduce((sum, processId) => {
                const process = visualizer.currentProcesses[processId];
                if (process) {
                    const valueType = process.attributes.value_type || 'VA';
                    if (valueType === 'VA') {
                        return sum + visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                    }
                }
                return sum;
            }, 0);

            // Count processes by value type
            const vaCount = criticalPath.filter(pid => {
                const p = visualizer.currentProcesses[pid];
                return p && (p.attributes.value_type || 'VA') === 'VA';
            }).length;
            const nnvaCount = criticalPath.filter(pid => {
                const p = visualizer.currentProcesses[pid];
                return p && p.attributes.value_type === 'NNVA';
            }).length;
            const nvaCount = criticalPath.filter(pid => {
                const p = visualizer.currentProcesses[pid];
                return p && p.attributes.value_type === 'NVA';
            }).length;

            // Get Total Lead Time (critical path time)
            const totalLeadTime = visualizer.criticalPathData.time || 0;

            // Calculate PCE using value-adding time only
            const pce = totalLeadTime > 0 ? (valueAddingProcessTime / totalLeadTime) * 100 : 0;

            let html = '<div style="margin-bottom: 20px;">';
            html += '<p style="font-size: 14px; line-height: 1.6; color: #2c3e50;">';
            html += '<strong>Process Cycle Efficiency (PCE)</strong> measures the percentage of time that truly adds value to the product or service. ';
            html += 'It only counts process time from <span style="color: #27ae60; font-weight: bold;">VA</span> (Value Add) processes. ';
            html += '<span style="color: #f39c12; font-weight: bold;">NNVA</span> (Necessary Non-Value Add) and ';
            html += '<span style="color: #e74c3c; font-weight: bold;">NVA</span> (Non-Value Add) processes are excluded.';
            html += '</p>';
            html += '</div>';

            // Show the formula
            html += '<div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">';
            html += '<div style="text-align: center; font-size: 16px; margin-bottom: 10px;"><strong>Formula:</strong></div>';
            html += '<div style="text-align: center; font-size: 14px; font-family: monospace; color: #2c3e50;">';
            html += 'PCE = (VA Process Time / Total Lead Time) Ã— 100';
            html += '</div>';
            html += '</div>';

            // Show the calculation
            html += '<div style="background: #fff; border: 1px solid #bdc3c7; border-radius: 5px; padding: 15px; margin-bottom: 20px;">';
            html += '<div style="text-align: center; font-size: 16px; margin-bottom: 15px;"><strong>Calculation:</strong></div>';
            
            // Helper function to get value type badge HTML
            const getValueTypeBadge = (valueType) => {
                const colors = {
                    'VA': { bg: '#27ae60', text: '#fff' },
                    'NVA': { bg: '#e74c3c', text: '#fff' },
                    'NNVA': { bg: '#f39c12', text: '#fff' }
                };
                const color = colors[valueType] || colors['VA'];
                return `<span style="display: inline-block; padding: 1px 5px; margin-right: 6px; background: ${color.bg}; color: ${color.text}; border-radius: 3px; font-size: 9px; font-weight: bold; vertical-align: middle;">${valueType}</span>`;
            };

            // Show process counts by type
            html += '<div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">';
            html += '<div style="font-size: 12px; margin-bottom: 8px;"><strong>Processes on Critical Path:</strong></div>';
            html += `<span style="display: inline-block; padding: 2px 8px; margin: 2px; background: #27ae60; color: white; border-radius: 3px; font-size: 11px;">VA: ${vaCount}</span>`;
            html += `<span style="display: inline-block; padding: 2px 8px; margin: 2px; background: #f39c12; color: white; border-radius: 3px; font-size: 11px;">NNVA: ${nnvaCount}</span>`;
            html += `<span style="display: inline-block; padding: 2px 8px; margin: 2px; background: #e74c3c; color: white; border-radius: 3px; font-size: 11px;">NVA: ${nvaCount}</span>`;
            
            // List each process with badge
            html += '<div style="margin-top: 10px; font-size: 12px;">';
            criticalPath.forEach((processId, index) => {
                const process = visualizer.currentProcesses[processId];
                if (process) {
                    const name = process.attributes.name || processId;
                    const valueType = process.attributes.value_type || 'VA';
                    const pt = visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                    const badge = getValueTypeBadge(valueType);
                    const includedStyle = valueType === 'VA' ? 'color: #27ae60;' : 'color: #95a5a6; text-decoration: line-through;';
                    html += `<div style="padding: 3px 0; ${includedStyle}">${badge}${name} <span style="font-family: monospace;">${pt.toFixed(2)}d</span></div>`;
                }
            });
            html += '</div>';
            html += '</div>';
            
            html += '<div class="breakdown-row" style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #ecf0f1;">';
            html += '<div class="breakdown-name">VA Process Time (value-adding)</div>';
            html += `<div class="breakdown-value" style="color: #27ae60;">${valueAddingProcessTime.toFixed(2)}d</div>`;
            html += '</div>';

            html += '<div class="breakdown-row" style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #ecf0f1; color: #7f8c8d;">';
            html += '<div class="breakdown-name" style="color: #7f8c8d;">Total Process Time (all types)</div>';
            html += `<div class="breakdown-value" style="color: #7f8c8d;">${totalProcessTime.toFixed(2)}d</div>`;
            html += '</div>';

            html += '<div class="breakdown-row" style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #ecf0f1;">';
            html += '<div class="breakdown-name">Total Lead Time (Critical Path)</div>';
            html += `<div class="breakdown-value">${totalLeadTime.toFixed(2)}d</div>`;
            html += '</div>';

            html += '<div class="breakdown-row" style="display: flex; justify-content: space-between; padding: 12px 0; margin-top: 10px; background: #e8f5e9; border-radius: 5px; padding-left: 10px; padding-right: 10px;">';
            html += '<div class="breakdown-name" style="font-weight: bold; font-size: 16px;">PCE</div>';
            html += `<div class="breakdown-value" style="font-weight: bold; font-size: 16px; color: #27ae60;">${pce.toFixed(1)}%</div>`;
            html += '</div>';

            html += '</div>';

            // Show interpretation
            html += '<div style="background: #fff3cd; padding: 15px; border-radius: 5px; border-left: 4px solid #ffc107;">';
            html += '<div style="font-weight: bold; margin-bottom: 8px; color: #856404;">ðŸ’¡ Interpretation:</div>';
            html += '<ul style="margin: 0; padding-left: 20px; color: #856404; font-size: 13px;">';
            
            if (pce >= 25) {
                html += '<li>Your PCE is <strong>above average</strong>. Good efficiency!</li>';
            } else if (pce >= 10) {
                html += '<li>Your PCE is <strong>typical</strong> for many processes.</li>';
            } else {
                html += '<li>Your PCE indicates significant waiting time or waste.</li>';
            }
            
            html += '<li>Higher PCE means more value-added time relative to total time.</li>';
            html += '<li>To improve PCE: reduce wait times and convert NNVA/NVA to VA where possible.</li>';
            html += '<li>Eliminate NVA processes; minimize NNVA processes.</li>';
            html += '<li>World-class manufacturers often target PCE > 25%.</li>';
            html += '</ul>';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        function showWaitTimeBreakdown() {
            const breakdownDiv = document.getElementById('waitTimeBreakdown');

            // Get critical path data
            const criticalPathProcessIds = new Set(visualizer.criticalPathData?.path || []);
            const criticalFlows = visualizer.criticalPathData?.flows || new Set();

            // Calculate wait times (include all processes, even with 0 wait time)
            const processWaitTimesCritical = [];
            const processWaitTimesOther = [];
            let totalProcessWT = 0;
            let maxWaitTime = -1;

            Object.entries(visualizer.currentProcesses).forEach(([processId, process]) => {
                const wtValue = visualizer.convertTimeToStandardUnit(process.attributes.wait_time);
                if (wtValue > maxWaitTime) {
                    maxWaitTime = wtValue;
                }
                const item = {
                    name: process.attributes.name || processId,
                    value: process.attributes.wait_time,
                    numericValue: wtValue,
                    isZero: wtValue === 0,
                    valueType: process.attributes.value_type || 'VA'
                };
                if (criticalPathProcessIds.has(processId)) {
                    processWaitTimesCritical.push(item);
                } else {
                    processWaitTimesOther.push(item);
                }
                totalProcessWT += wtValue;
            });

            const flowWaitTimesCritical = [];
            const flowWaitTimesOther = [];
            let totalFlowWT = 0;
            let maxFlowWaitTime = -1;

            visualizer.currentFlows.forEach(flow => {
                const wtValue = visualizer.convertTimeToStandardUnit(flow.wait_time);
                if (wtValue > maxFlowWaitTime) {
                    maxFlowWaitTime = wtValue;
                }
                const fromName = visualizer.currentProcesses[flow.from]?.attributes?.name || flow.from;
                const toName = visualizer.currentProcesses[flow.to]?.attributes?.name || flow.to;
                const flowKey = `${flow.from}-${flow.to}`;
                const item = {
                    name: `${fromName} â†’ ${toName}`,
                    value: flow.wait_time,
                    numericValue: wtValue,
                    isZero: wtValue === 0,
                    valueType: flow.value_type || 'NVA'
                };
                if (criticalFlows.has(flowKey)) {
                    flowWaitTimesCritical.push(item);
                } else {
                    flowWaitTimesOther.push(item);
                }
                totalFlowWT += wtValue;
            });

            const totalWT = totalProcessWT + totalFlowWT;

            // Build HTML
            let html = '';

            // Helper function to get value type badge HTML
            const getValueTypeBadge = (valueType) => {
                const colors = {
                    'VA': { bg: '#27ae60', text: '#fff' },
                    'NVA': { bg: '#e74c3c', text: '#fff' },
                    'NNVA': { bg: '#f39c12', text: '#fff' }
                };
                const color = colors[valueType] || colors['VA'];
                return `<span style="display: inline-block; padding: 1px 5px; margin-right: 6px; background: ${color.bg}; color: ${color.text}; border-radius: 3px; font-size: 9px; font-weight: bold; vertical-align: middle;">${valueType}</span>`;
            };

            // Helper function to render wait time items
            const renderWaitTimeItems = (items, maxValue) => {
                items.forEach(item => {
                    let itemStyle = '';
                    if (item.isZero) {
                        itemStyle = 'color: #27ae60;'; // Green for zero wait time
                    } else if (item.numericValue === maxValue && maxValue > 0) {
                        itemStyle = 'color: red;'; // Red for longest wait time (excluding zeros)
                    }
                    const badge = getValueTypeBadge(item.valueType);
                    html += `<div class="breakdown-item">
                        <div class="breakdown-name" style="${itemStyle}">${badge}${item.name}</div>
                        <div class="breakdown-value" style="${itemStyle}">${item.value}</div>
                    </div>`;
                });
            };

            // Process Wait Times section
            if (processWaitTimesCritical.length > 0 || processWaitTimesOther.length > 0) {
                html += '<div class="breakdown-section">';
                html += '<h4>Process Wait Times</h4>';
                
                // Critical Path processes
                if (processWaitTimesCritical.length > 0) {
                    html += '<h5 style="color: #e67e22; margin: 10px 0 5px 0; font-size: 0.95em;">Critical Path</h5>';
                    renderWaitTimeItems(processWaitTimesCritical, maxWaitTime);
                }
                
                // Other processes
                if (processWaitTimesOther.length > 0) {
                    html += '<h5 style="color: #7f8c8d; margin: 10px 0 5px 0; font-size: 0.95em;">Other</h5>';
                    renderWaitTimeItems(processWaitTimesOther, maxWaitTime);
                }
                
                html += `<div class="breakdown-item" style="font-weight: bold; color: #3498db;">
                    <div class="breakdown-name">Subtotal</div>
                    <div class="breakdown-value">${totalProcessWT.toFixed(1)}d</div>
                </div>`;
                html += '</div>';
            }

            // Flow Wait Times section
            if (flowWaitTimesCritical.length > 0 || flowWaitTimesOther.length > 0) {
                html += '<div class="breakdown-section">';
                html += '<h4>Flow Wait Times (Inter-Process)</h4>';
                
                // Critical Path flows
                if (flowWaitTimesCritical.length > 0) {
                    html += '<h5 style="color: #e67e22; margin: 10px 0 5px 0; font-size: 0.95em;">Critical Path</h5>';
                    renderWaitTimeItems(flowWaitTimesCritical, maxFlowWaitTime);
                }
                
                // Other flows
                if (flowWaitTimesOther.length > 0) {
                    html += '<h5 style="color: #7f8c8d; margin: 10px 0 5px 0; font-size: 0.95em;">Other</h5>';
                    renderWaitTimeItems(flowWaitTimesOther, maxFlowWaitTime);
                }
                
                html += `<div class="breakdown-item" style="font-weight: bold; color: #3498db;">
                    <div class="breakdown-name">Subtotal</div>
                    <div class="breakdown-value">${totalFlowWT.toFixed(1)}d</div>
                </div>`;
                html += '</div>';
            }

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Total Wait Time</div>';
            html += `<div class="breakdown-value">${totalWT.toFixed(1)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Total Wait Time = Sum of Process Wait Times + Sum of Flow Wait Times';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        function showLeadTimeBreakdown() {
            const breakdownDiv = document.getElementById('leadTimeBreakdown');

            if (!visualizer.criticalPathData || !visualizer.criticalPathData.path) {
                breakdownDiv.innerHTML = '<p style="color: #7f8c8d;">No critical path data available.</p>';
                return;
            }

            const criticalPath = visualizer.criticalPathData.path;
            const criticalPathTime = visualizer.criticalPathData.time;

            let html = '';

            // Critical Path Sequence section
            html += '<div class="breakdown-section">';
            html += '<h4>Critical Path Sequence</h4>';
            html += '<p style="color: #7f8c8d; font-size: 0.9em; margin-bottom: 10px;">Process Time (PT) + Wait Time (WT) for each process along the critical path</p>';

            let runningTotal = 0;

            // Helper function to get value type badge HTML
            const getValueTypeBadge = (valueType) => {
                const colors = {
                    'VA': { bg: '#27ae60', text: '#fff' },
                    'NVA': { bg: '#e74c3c', text: '#fff' },
                    'NNVA': { bg: '#f39c12', text: '#fff' }
                };
                const color = colors[valueType] || colors['VA'];
                return `<span style="display: inline-block; padding: 1px 5px; margin-right: 6px; background: ${color.bg}; color: ${color.text}; border-radius: 3px; font-size: 9px; font-weight: bold; vertical-align: middle;">${valueType}</span>`;
            };

            criticalPath.forEach((processId, index) => {
                const process = visualizer.currentProcesses[processId];
                if (!process) return;

                const processName = process.attributes.name || processId;
                const pt = visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                const wt = visualizer.convertTimeToStandardUnit(process.attributes.wait_time);
                const cycleTime = pt + wt;
                const processValueType = process.attributes.value_type || 'VA';
                const processBadge = getValueTypeBadge(processValueType);

                html += `<div class="breakdown-item">
                    <div class="breakdown-name">${processBadge}${index + 1}. ${processName}</div>
                    <div class="breakdown-value">${process.attributes.process_time} PT + ${process.attributes.wait_time} WT = ${cycleTime.toFixed(2)}d</div>
                </div>`;

                runningTotal += cycleTime;

                // Add flow wait time if not the last process
                if (index < criticalPath.length - 1) {
                    const nextProcessId = criticalPath[index + 1];
                    const flow = visualizer.currentFlows.find(f => f.from === processId && f.to === nextProcessId);
                    if (flow) {
                        const flowWT = visualizer.convertTimeToStandardUnit(flow.wait_time);
                        const flowValueType = flow.value_type || 'NVA';
                        const flowBadge = getValueTypeBadge(flowValueType);
                        html += `<div class="breakdown-item" style="padding-left: 20px; color: #7f8c8d;">
                            <div class="breakdown-name">${flowBadge}â†“ Flow Wait Time</div>
                            <div class="breakdown-value">${flow.wait_time}</div>
                        </div>`;
                        runningTotal += flowWT;
                    }
                }
            });

            html += '</div>';

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Total Lead Time (Critical Path)</div>';
            html += `<div class="breakdown-value">${criticalPathTime.toFixed(2)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Total Lead Time = Critical Path Time<br>';
            html += 'Critical Path = Longest path from start to end, considering Process Time, Process Wait Time, and Flow Wait Times';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        function showProcessTimeBreakdown() {
            const breakdownDiv = document.getElementById('processTimeBreakdown');

            // Get critical path data
            const criticalPathProcessIds = new Set(visualizer.criticalPathData?.path || []);

            const processTimesCritical = [];
            const processTimesOther = [];
            let totalPT = 0;
            let maxProcessTime = -1;

            Object.entries(visualizer.currentProcesses).forEach(([processId, process]) => {
                const ptValue = visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                if (ptValue > maxProcessTime) {
                    maxProcessTime = ptValue;
                }
                const item = {
                    name: process.attributes.name || processId,
                    value: process.attributes.process_time,
                    numericValue: ptValue,
                    isZero: ptValue === 0,
                    valueType: process.attributes.value_type || 'VA'
                };
                if (criticalPathProcessIds.has(processId)) {
                    processTimesCritical.push(item);
                } else {
                    processTimesOther.push(item);
                }
                totalPT += ptValue;
            });

            // Sort by numeric value (descending)
            processTimesCritical.sort((a, b) => b.numericValue - a.numericValue);
            processTimesOther.sort((a, b) => b.numericValue - a.numericValue);

            let html = '';

            // Helper function to get value type badge HTML
            const getValueTypeBadge = (valueType) => {
                const colors = {
                    'VA': { bg: '#27ae60', text: '#fff' },
                    'NVA': { bg: '#e74c3c', text: '#fff' },
                    'NNVA': { bg: '#f39c12', text: '#fff' }
                };
                const color = colors[valueType] || colors['VA'];
                return `<span style="display: inline-block; padding: 1px 5px; margin-right: 6px; background: ${color.bg}; color: ${color.text}; border-radius: 3px; font-size: 9px; font-weight: bold; vertical-align: middle;">${valueType}</span>`;
            };

            // Helper function to render process time items
            const renderProcessTimeItems = (items) => {
                items.forEach(item => {
                    let itemStyle = '';
                    if (item.isZero) {
                        itemStyle = 'color: #27ae60;'; // Green for zero process time
                    } else if (item.numericValue === maxProcessTime && maxProcessTime > 0) {
                        itemStyle = 'color: red;'; // Red for longest process time (excluding zeros)
                    }
                    const badge = getValueTypeBadge(item.valueType);
                    html += `<div class="breakdown-item">
                        <div class="breakdown-name" style="${itemStyle}">${badge}${item.name}</div>
                        <div class="breakdown-value" style="${itemStyle}">${item.value}</div>
                    </div>`;
                });
            };

            // Process Times section
            html += '<div class="breakdown-section">';
            html += '<h4>Process Times</h4>';
            html += '<p style="color: #7f8c8d; font-size: 0.9em; margin-bottom: 10px;">Time spent actively working on each process</p>';
            
            // Critical Path processes
            if (processTimesCritical.length > 0) {
                html += '<h5 style="color: #e67e22; margin: 10px 0 5px 0; font-size: 0.95em;">Critical Path</h5>';
                renderProcessTimeItems(processTimesCritical);
            }
            
            // Other processes
            if (processTimesOther.length > 0) {
                html += '<h5 style="color: #7f8c8d; margin: 10px 0 5px 0; font-size: 0.95em;">Other</h5>';
                renderProcessTimeItems(processTimesOther);
            }
            html += '</div>';

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Total Process Time</div>';
            html += `<div class="breakdown-value">${totalPT.toFixed(2)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Total Process Time = Sum of all Process Times<br>';
            html += '<strong>Note:</strong> This is the total value-add time across all processes.';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        function showCriticalPathBreakdown() {
            const breakdownDiv = document.getElementById('criticalPathBreakdown');

            if (!visualizer.criticalPathData || !visualizer.criticalPathData.path) {
                breakdownDiv.innerHTML = '<p style="color: #7f8c8d;">No critical path data available.</p>';
                return;
            }

            const criticalPath = visualizer.criticalPathData.path;
            const criticalPathTime = visualizer.criticalPathData.time;

            let html = '';

            // Critical Path Visualization
            html += '<div class="breakdown-section">';
            html += '<h4>Critical Path Details</h4>';
            html += '<p style="color: #7f8c8d; font-size: 0.9em; margin-bottom: 10px;">The longest path through the value stream, determining the minimum lead time</p>';

            // Helper function to get value type badge HTML
            const getValueTypeBadge = (valueType) => {
                const colors = {
                    'VA': { bg: '#27ae60', text: '#fff' },
                    'NVA': { bg: '#e74c3c', text: '#fff' },
                    'NNVA': { bg: '#f39c12', text: '#fff' }
                };
                const color = colors[valueType] || colors['VA'];
                return `<span style="display: inline-block; padding: 1px 5px; margin-right: 6px; background: ${color.bg}; color: ${color.text}; border-radius: 3px; font-size: 9px; font-weight: bold; vertical-align: middle;">${valueType}</span>`;
            };

            // Process sequence with badges
            html += '<div style="padding: 15px; background: #fff3cd; border-left: 4px solid #e67e22; margin-bottom: 15px;">';
            html += '<strong style="color: #e67e22;">Critical Path Sequence:</strong><br>';
            const pathItems = criticalPath.map(processId => {
                const process = visualizer.currentProcesses[processId];
                const name = process ? (process.attributes.name || processId) : processId;
                const valueType = process ? (process.attributes.value_type || 'VA') : 'VA';
                const badge = getValueTypeBadge(valueType);
                return badge + '<span style="color: #2c3e50;">' + name + '</span>';
            });
            html += '<div style="font-family: monospace; line-height: 2;">' + pathItems.join(' â†’ ') + '</div>';
            html += '</div>';

            // Detailed breakdown
            let runningTotal = 0;

            criticalPath.forEach((processId, index) => {
                const process = visualizer.currentProcesses[processId];
                if (!process) return;

                const processName = process.attributes.name || processId;
                const pt = visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                const wt = visualizer.convertTimeToStandardUnit(process.attributes.wait_time);
                const cycleTime = pt + wt;
                const processValueType = process.attributes.value_type || 'VA';
                const processBadge = getValueTypeBadge(processValueType);

                html += `<div class="breakdown-item">
                    <div class="breakdown-name">${processBadge}${index + 1}. ${processName} (CT)</div>
                    <div class="breakdown-value">${cycleTime.toFixed(2)}d</div>
                </div>`;

                runningTotal += cycleTime;

                // Add flow wait time if not the last process
                if (index < criticalPath.length - 1) {
                    const nextProcessId = criticalPath[index + 1];
                    const flow = visualizer.currentFlows.find(f => f.from === processId && f.to === nextProcessId);
                    if (flow) {
                        const flowWT = visualizer.convertTimeToStandardUnit(flow.wait_time);
                        const flowValueType = flow.value_type || 'NVA';
                        const flowBadge = getValueTypeBadge(flowValueType);
                        html += `<div class="breakdown-item" style="padding-left: 20px; color: #7f8c8d;">
                            <div class="breakdown-name">${flowBadge}   + Flow WT</div>
                            <div class="breakdown-value">${flowWT.toFixed(2)}d</div>
                        </div>`;
                        runningTotal += flowWT;
                    }
                }
            });

            html += '</div>';

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Critical Path Time</div>';
            html += `<div class="breakdown-value">${criticalPathTime.toFixed(2)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Critical Path = Sum of (Cycle Times + Flow Wait Times) along the longest path<br>';
            html += '<strong>Where:</strong> Cycle Time (CT) = Process Time (PT) + Process Wait Time (WT)';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        // Make functions globally available
        window.parser = parser;
        window.saveVSM = saveVSM;
        window.parseAndVisualize = parseAndVisualize;
        window.addNewProcess = addNewProcess;
        window.saveVSMToFile = saveVSMToFile;
        window.loadVSMFromFile = loadVSMFromFile;

        // Initialize pane splitter
        function initializePaneSplitter() {
            const splitter = document.getElementById('paneSplitter');
            const editorPanel = document.querySelector('.editor-panel');
            const mainContent = document.querySelector('.main-content');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            splitter.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = editorPanel.offsetWidth;
                splitter.classList.add('active');
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'col-resize';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                const newWidth = Math.max(200, Math.min(startWidth + deltaX, mainContent.offsetWidth * 0.8));
                editorPanel.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    splitter.classList.remove('active');
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            });
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeVSM();
                initializePaneSplitter();
            });
        } else {
            initializeVSM();
            initializePaneSplitter();
        }
    </script>
</body>
</html>