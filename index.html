<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Value Stream Map Visualizer</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Value Stream Map Visualizer</h1>
            <p>Define your processes and flows using our DSL, then visualize your value stream map</p>
        </div>
        
        <div class="main-content">
            <div class="editor-panel collapsed">
                <button class="editor-toggle" title="Toggle DSL Editor">⟩</button>
                <div class="panel-header">
                    <div class="filename-display" id="currentFilename">
                        <span class="filename-label">File:</span>
                        <span class="filename-text">Untitled.vsm</span>
                    </div>
                    <div class="button-group">
                        <button class="editor-button" data-action="save-file">Save File</button>
                        <button class="editor-button" data-action="load-file">Load File</button>
                        <button class="editor-button" data-action="clear">New VSM</button>
                    </div>
                </div>
                <textarea id="dslEditor" class="editor" spellcheck="false">process process_1767166125801 {
  stage_id: "1"
  name: "Build"
  owner: ""
  description: "New process description"
  wait_time: "2d"
  process_time: "5d"
  defect_rate: "0"
}

process process_1767166125801_1 {
  stage_id: "2"
  name: "Test"
  owner: ""
  description: "New process derived from process_1767166125801"
  wait_time: "1d"
  process_time: "10d"
  defect_rate: "0"
}

process process_1767166125801_2 {
  stage_id: "2"
  name: "Create and Approve CR"
  owner: ""
  description: "New process derived from process_1767166125801"
  wait_time: "20d"
  process_time: "30m"
  defect_rate: "0"
}

process process_1767166125801_1_1 {
  stage_id: "3"
  name: "New Deploy"
  owner: ""
  description: "New process derived from process_1767166125801_1"
  wait_time: "0d"
  process_time: "20m"
  defect_rate: "0"
}

process process_1767166125801_1_2 {
  stage_id: 3
  name: "New Test"
  owner: ""
  description: "New process derived from process_1767166125801_1"
  wait_time: "0d"
  process_time: 200d
  defect_rate: "0"
}

process process_1767166125801_1_2_1 {
  stage_id: 4
  name: "New New Test"
  owner: ""
  description: "New process derived from process_1767166125801_1_2"
  wait_time: "0d"
  process_time: "0s"
  defect_rate: "0"
}

flow from process_1767166125801 to process_1767166125801_1 {
  wait_time: 1d
}

flow from process_1767166125801 to process_1767166125801_2 {
  wait_time: 0.5d
}

flow from process_1767166125801_1 to process_1767166125801_1_1 {
  wait_time: 10m
}

flow from process_1767166125801_2 to process_1767166125801_1_1 {
  wait_time: 0d
}

flow from process_1767166125801_1 to process_1767166125801_1_2 {
  wait_time: 0.5d
}

flow from process_1767166125801_1_2 to process_1767166125801_1_2_1 {
  wait_time: 0.5d
}

flow from process_1767166125801_1_1 to process_1767166125801_1_2_1 {
  wait_time: 0d
}

positions {
  process_1767166125801: 371, 290
  process_1767166125801_1: 635, 289
  process_1767166125801_2: 640, 465
  process_1767166125801_1_1: 958, 406
  process_1767166125801_1_2: 943, 212
  process_1767166125801_1_2_1: 1255, 326
}
</textarea>
                <button class="parse-button" onclick="parseAndVisualize()">Parse & Visualize</button>
                <input type="file" id="fileInput" accept=".vsm" style="display: none;">
            </div>
            <div class="pane-splitter" id="paneSplitter"></div>
            <div class="visualization-panel">
                <div class="canvas-container">
                    <svg id="vsmCanvas" width="900" height="700"></svg>
                </div>
            </div>
        </div>

        <div class="totals-strip">
            <div class="total-item clickable" id="leadTimeItem">
                <div class="total-label">Total Lead Time</div>
                <div class="total-value" id="totalLeadTime">-</div>
            </div>
            <div class="total-item clickable" id="waitTimeItem">
                <div class="total-label">Total Wait Time</div>
                <div class="total-value" id="totalWaitTime">-</div>
            </div>
            <div class="total-item clickable" id="processTimeItem">
                <div class="total-label">Total Process Time</div>
                <div class="total-value" id="totalProcessTime">-</div>
            </div>
            <div class="total-item clickable" id="criticalPathItem">
                <div class="total-label">Critical Path</div>
                <div class="critical-path" id="criticalPath">-</div>
            </div>
        </div>

        <!-- Wait Time Breakdown Modal -->
        <div id="waitTimeModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Total Wait Time Breakdown</h3>
                    <span class="modal-close" data-modal="waitTimeModal">&times;</span>
                </div>
                <div class="modal-body" id="waitTimeBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Lead Time Breakdown Modal -->
        <div id="leadTimeModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Total Lead Time Breakdown</h3>
                    <span class="modal-close" data-modal="leadTimeModal">&times;</span>
                </div>
                <div class="modal-body" id="leadTimeBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Process Time Breakdown Modal -->
        <div id="processTimeModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Total Process Time Breakdown</h3>
                    <span class="modal-close" data-modal="processTimeModal">&times;</span>
                </div>
                <div class="modal-body" id="processTimeBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Critical Path Breakdown Modal -->
        <div id="criticalPathModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Critical Path Breakdown</h3>
                    <span class="modal-close" data-modal="criticalPathModal">&times;</span>
                </div>
                <div class="modal-body" id="criticalPathBreakdown">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import VSMParser from './js/VSMParser.js';
        import VSMVisualizer from './js/VSMVisualizer.js';

        const parser = new VSMParser();
        let visualizer;

        // Filename state management
        let currentFilename = 'Untitled.vsm';
        let isModified = false;

        function updateFilenameDisplay() {
            const filenameElement = document.querySelector('.filename-text');
            if (filenameElement) {
                filenameElement.textContent = currentFilename;
                if (isModified) {
                    filenameElement.classList.add('modified');
                } else {
                    filenameElement.classList.remove('modified');
                }
            }
        }

        function setFilename(name) {
            currentFilename = name;
            isModified = false;
            updateFilenameDisplay();
            // Store in localStorage for persistence
            localStorage.setItem('vsmCurrentFilename', currentFilename);
        }

        function markAsModified() {
            isModified = true;
            updateFilenameDisplay();
        }

        // Load saved filename on initialization
        function loadSavedFilename() {
            const savedFilename = localStorage.getItem('vsmCurrentFilename');
            if (savedFilename) {
                currentFilename = savedFilename;
            }
            updateFilenameDisplay();
        }

        function clearVSM() {
            const processId = `process_${Date.now()}`;

            // Create default DSL with one process
            const defaultDSL = `process ${processId} {
  stage_id: 1
  name: "New Process"
  owner: ""
  description: "New process description"
  wait_time: 0d
  process_time: 0s
  defect_rate: 0
}`;

            // Set the DSL editor
            document.getElementById('dslEditor').value = defaultDSL;

            // Create the default process structure
            const defaultProcess = {
                attributes: {
                    stage_id: 1,
                    name: "New Process",
                    owner: "",
                    description: "New process description",
                    wait_time: "0d",
                    process_time: "0s",
                    defect_rate: "0"
                }
            };

            // Reset the visualizer data with the default process
            visualizer.currentProcesses = { [processId]: defaultProcess };
            visualizer.currentFlows = [];
            visualizer.currentInfoFlows = [];

            // Position the process in the center
            const centerX = visualizer.width / 2 - visualizer.processWidth / 2;
            const centerY = visualizer.height / 2 - visualizer.processHeight / 2;
            visualizer.positions = { [processId]: { x: centerX, y: centerY } };

            // Visualize with the default process
            visualizer.visualize({
                processes: visualizer.currentProcesses,
                flows: [],
                infoFlows: [],
                positions: visualizer.positions
            });

            // Reset filename
            setFilename('Untitled.vsm');
            // Clear localStorage filename
            localStorage.removeItem('vsmCurrentFilename');
        }

        async function initializeVSM() {
            visualizer = new VSMVisualizer(document.getElementById('vsmCanvas'));
            
            // Try to load saved state first
            if (!visualizer.loadState()) {
                // If no saved state, load initial DSL
                const initialData = parser.loadInitialDSL();
                visualizer.visualize(initialData);
            }

            // Setup editor panel toggle
            const editorPanel = document.querySelector('.editor-panel');
            const toggleButton = document.querySelector('.editor-toggle');
            
            if (toggleButton) {
                toggleButton.addEventListener('click', () => {
                    editorPanel.classList.toggle('collapsed');
                    toggleButton.textContent = editorPanel.classList.contains('collapsed') ? '⟩' : '⟨';
                });
            }

            // Add button click handlers
            document.querySelector('[data-action="clear"]').addEventListener('click', clearVSM);
            document.querySelector('[data-action="save-file"]').addEventListener('click', saveVSMToFile);
            document.querySelector('[data-action="load-file"]').addEventListener('click', loadVSMFromFile);

            // Track editor modifications
            document.getElementById('dslEditor').addEventListener('input', markAsModified);

            // Load saved filename on init
            loadSavedFilename();

            // Setup all breakdown modals
            setupWaitTimeModal();
            setupLeadTimeModal();
            setupProcessTimeModal();
            setupCriticalPathModal();
            setupModalCloseHandlers();
        }

        function parseAndVisualize() {
            const dslText = document.getElementById('dslEditor').value;
            const parsedData = parser.parse(dslText);
            
            // No time validation needed since CT is calculated as PT + WT
            
            // If validation passes, update visualization
            visualizer.visualize(parsedData);
        }

        function saveVSM() {
            if (visualizer) {
                visualizer.saveState();
            }
        }

        function addNewProcess() {
            const processId = `process_${Date.now()}`;
            const newProcess = {
                attributes: {
                    stage_id: 1,
                    name: "New Process",
                    owner: "",
                    description: "New process description",
                    wait_time: "0d",
                    process_time: "0s",
                    defect_rate: "0"
                }
            };

            // Add to current processes
            visualizer.currentProcesses[processId] = newProcess;

            // Calculate position for new process
            const centerX = visualizer.width / 2 - visualizer.processWidth / 2;
            const centerY = visualizer.height / 2 - visualizer.processHeight / 2;
            visualizer.positions[processId] = { x: centerX, y: centerY };

            // Update the DSL text
            const dslEditor = document.getElementById('dslEditor');
            const processBlock = `\nprocess ${processId} {
  stage_id: 1
  name: "New Process"
  owner: ""
  description: "New process description"
  wait_time: 0d
  process_time: 0s
  defect_rate: 0
}\n`;
            
            dslEditor.value += processBlock;

            // Redraw the visualization
            visualizer.visualize({
                processes: visualizer.currentProcesses,
                flows: visualizer.currentFlows,
                infoFlows: visualizer.currentInfoFlows,
                positions: visualizer.positions
            });
        }

        function saveVSMToFile() {
            try {
                // Get current state from visualizer
                const currentState = {
                    processes: visualizer.currentProcesses,
                    flows: visualizer.currentFlows,
                    infoFlows: visualizer.currentInfoFlows,
                    positions: visualizer.positions
                };

                // Serialize to DSL format
                const dslContent = parser.serialize(currentState);

                // Create blob and download
                const blob = new Blob([dslContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                // Create temporary download link
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = currentFilename;

                // Trigger download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

                // Clean up
                URL.revokeObjectURL(url);

                // Mark as saved
                isModified = false;
                updateFilenameDisplay();

                console.log('VSM saved to file:', currentFilename);
            } catch (error) {
                console.error('Error saving VSM file:', error);
                alert('Error saving file: ' + error.message);
            }
        }

        function loadVSMFromFile() {
            const fileInput = document.getElementById('fileInput');

            // Set up the file input handler
            fileInput.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;

                // Validate file extension
                if (!file.name.endsWith('.vsm')) {
                    alert('Invalid file type. Please select a .vsm file.');
                    fileInput.value = '';
                    return;
                }

                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        const dslContent = e.target.result;

                        // Validate DSL content
                        const parsedData = parser.parse(dslContent);

                        // Basic validation: check if we have processes
                        if (!parsedData.processes || Object.keys(parsedData.processes).length === 0) {
                            throw new Error('Invalid VSM file: No processes found');
                        }

                        // Load into editor
                        document.getElementById('dslEditor').value = dslContent;

                        // Visualize the loaded data
                        visualizer.visualize(parsedData);

                        // Update filename
                        setFilename(file.name);

                        // Save to localStorage for auto-recovery
                        visualizer.saveState();

                        console.log('VSM loaded from file:', file.name);
                    } catch (error) {
                        console.error('Error loading VSM file:', error);
                        alert('Error loading file: ' + error.message + '\n\nPlease check that the file is a valid VSM DSL file.');
                    } finally {
                        // Reset file input
                        fileInput.value = '';
                    }
                };

                reader.onerror = function() {
                    alert('Error reading file. Please try again.');
                    fileInput.value = '';
                };

                reader.readAsText(file);
            };

            // Trigger file selection dialog
            fileInput.click();
        }

        function setupWaitTimeModal() {
            const modal = document.getElementById('waitTimeModal');
            const waitTimeItem = document.getElementById('waitTimeItem');

            // Open modal on click
            waitTimeItem.addEventListener('click', () => {
                showWaitTimeBreakdown();
                modal.style.display = 'block';
            });
        }

        function setupLeadTimeModal() {
            const modal = document.getElementById('leadTimeModal');
            const leadTimeItem = document.getElementById('leadTimeItem');

            // Open modal on click
            leadTimeItem.addEventListener('click', () => {
                showLeadTimeBreakdown();
                modal.style.display = 'block';
            });
        }

        function setupProcessTimeModal() {
            const modal = document.getElementById('processTimeModal');
            const processTimeItem = document.getElementById('processTimeItem');

            // Open modal on click
            processTimeItem.addEventListener('click', () => {
                showProcessTimeBreakdown();
                modal.style.display = 'block';
            });
        }

        function setupCriticalPathModal() {
            const modal = document.getElementById('criticalPathModal');
            const criticalPathItem = document.getElementById('criticalPathItem');

            // Open modal on click
            criticalPathItem.addEventListener('click', () => {
                showCriticalPathBreakdown();
                modal.style.display = 'block';
            });
        }

        // Generic modal close handlers
        function setupModalCloseHandlers() {
            // Close modal on X button click
            document.querySelectorAll('.modal-close').forEach(closeBtn => {
                closeBtn.addEventListener('click', (e) => {
                    const modalId = e.target.getAttribute('data-modal');
                    const modal = document.getElementById(modalId);
                    if (modal) {
                        modal.style.display = 'none';
                    }
                });
            });

            // Close modal on outside click
            window.addEventListener('click', (event) => {
                if (event.target.classList.contains('modal')) {
                    event.target.style.display = 'none';
                }
            });

            // Close all modals on Escape key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    document.querySelectorAll('.modal').forEach(modal => {
                        if (modal.style.display === 'block') {
                            modal.style.display = 'none';
                        }
                    });
                }
            });
        }

        function showWaitTimeBreakdown() {
            const breakdownDiv = document.getElementById('waitTimeBreakdown');

            // Calculate wait times
            const processWaitTimes = [];
            let totalProcessWT = 0;

            Object.entries(visualizer.currentProcesses).forEach(([processId, process]) => {
                const wtValue = visualizer.convertTimeToStandardUnit(process.attributes.wait_time);
                if (wtValue > 0) {
                    processWaitTimes.push({
                        name: process.attributes.name || processId,
                        value: process.attributes.wait_time,
                        numericValue: wtValue
                    });
                    totalProcessWT += wtValue;
                }
            });

            const flowWaitTimes = [];
            let totalFlowWT = 0;

            visualizer.currentFlows.forEach(flow => {
                const wtValue = visualizer.convertTimeToStandardUnit(flow.wait_time);
                if (wtValue > 0) {
                    const fromName = visualizer.currentProcesses[flow.from]?.attributes?.name || flow.from;
                    const toName = visualizer.currentProcesses[flow.to]?.attributes?.name || flow.to;
                    flowWaitTimes.push({
                        name: `${fromName} → ${toName}`,
                        value: flow.wait_time,
                        numericValue: wtValue
                    });
                    totalFlowWT += wtValue;
                }
            });

            const totalWT = totalProcessWT + totalFlowWT;

            // Build HTML
            let html = '';

            // Process Wait Times section
            if (processWaitTimes.length > 0) {
                html += '<div class="breakdown-section">';
                html += '<h4>Process Wait Times</h4>';
                processWaitTimes.forEach(item => {
                    html += `<div class="breakdown-item">
                        <div class="breakdown-name">${item.name}</div>
                        <div class="breakdown-value">${item.value}</div>
                    </div>`;
                });
                html += `<div class="breakdown-item" style="font-weight: bold; color: #3498db;">
                    <div class="breakdown-name">Subtotal</div>
                    <div class="breakdown-value">${totalProcessWT.toFixed(1)}d</div>
                </div>`;
                html += '</div>';
            }

            // Flow Wait Times section
            if (flowWaitTimes.length > 0) {
                html += '<div class="breakdown-section">';
                html += '<h4>Flow Wait Times (Inter-Process)</h4>';
                flowWaitTimes.forEach(item => {
                    html += `<div class="breakdown-item">
                        <div class="breakdown-name">${item.name}</div>
                        <div class="breakdown-value">${item.value}</div>
                    </div>`;
                });
                html += `<div class="breakdown-item" style="font-weight: bold; color: #3498db;">
                    <div class="breakdown-name">Subtotal</div>
                    <div class="breakdown-value">${totalFlowWT.toFixed(1)}d</div>
                </div>`;
                html += '</div>';
            }

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Total Wait Time</div>';
            html += `<div class="breakdown-value">${totalWT.toFixed(1)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Total Wait Time = Sum of Process Wait Times + Sum of Flow Wait Times';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        function showLeadTimeBreakdown() {
            const breakdownDiv = document.getElementById('leadTimeBreakdown');

            if (!visualizer.criticalPathData || !visualizer.criticalPathData.path) {
                breakdownDiv.innerHTML = '<p style="color: #7f8c8d;">No critical path data available.</p>';
                return;
            }

            const criticalPath = visualizer.criticalPathData.path;
            const criticalPathTime = visualizer.criticalPathData.time;

            let html = '';

            // Critical Path Sequence section
            html += '<div class="breakdown-section">';
            html += '<h4>Critical Path Sequence</h4>';
            html += '<p style="color: #7f8c8d; font-size: 0.9em; margin-bottom: 10px;">Process Time (PT) + Wait Time (WT) for each process along the critical path</p>';

            let runningTotal = 0;

            criticalPath.forEach((processId, index) => {
                const process = visualizer.currentProcesses[processId];
                if (!process) return;

                const processName = process.attributes.name || processId;
                const pt = visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                const wt = visualizer.convertTimeToStandardUnit(process.attributes.wait_time);
                const cycleTime = pt + wt;

                html += `<div class="breakdown-item">
                    <div class="breakdown-name">${index + 1}. ${processName}</div>
                    <div class="breakdown-value">${process.attributes.process_time} PT + ${process.attributes.wait_time} WT = ${cycleTime.toFixed(4)}d</div>
                </div>`;

                runningTotal += cycleTime;

                // Add flow wait time if not the last process
                if (index < criticalPath.length - 1) {
                    const nextProcessId = criticalPath[index + 1];
                    const flow = visualizer.currentFlows.find(f => f.from === processId && f.to === nextProcessId);
                    if (flow) {
                        const flowWT = visualizer.convertTimeToStandardUnit(flow.wait_time);
                        html += `<div class="breakdown-item" style="padding-left: 20px; color: #7f8c8d;">
                            <div class="breakdown-name">↓ Flow Wait Time</div>
                            <div class="breakdown-value">${flow.wait_time}</div>
                        </div>`;
                        runningTotal += flowWT;
                    }
                }
            });

            html += '</div>';

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Total Lead Time (Critical Path)</div>';
            html += `<div class="breakdown-value">${criticalPathTime.toFixed(4)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Total Lead Time = Critical Path Time<br>';
            html += 'Critical Path = Longest path from start to end, considering Process Time, Process Wait Time, and Flow Wait Times';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        function showProcessTimeBreakdown() {
            const breakdownDiv = document.getElementById('processTimeBreakdown');

            const processTimes = [];
            let totalPT = 0;

            Object.entries(visualizer.currentProcesses).forEach(([processId, process]) => {
                const ptValue = visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                processTimes.push({
                    name: process.attributes.name || processId,
                    value: process.attributes.process_time,
                    numericValue: ptValue
                });
                totalPT += ptValue;
            });

            // Sort by numeric value (descending)
            processTimes.sort((a, b) => b.numericValue - a.numericValue);

            let html = '';

            // Process Times section
            html += '<div class="breakdown-section">';
            html += '<h4>Process Times</h4>';
            html += '<p style="color: #7f8c8d; font-size: 0.9em; margin-bottom: 10px;">Time spent actively working on each process</p>';
            processTimes.forEach(item => {
                html += `<div class="breakdown-item">
                    <div class="breakdown-name">${item.name}</div>
                    <div class="breakdown-value">${item.value}</div>
                </div>`;
            });
            html += '</div>';

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Total Process Time</div>';
            html += `<div class="breakdown-value">${totalPT.toFixed(4)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Total Process Time = Sum of all Process Times<br>';
            html += '<strong>Note:</strong> This is the total value-add time across all processes.';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        function showCriticalPathBreakdown() {
            const breakdownDiv = document.getElementById('criticalPathBreakdown');

            if (!visualizer.criticalPathData || !visualizer.criticalPathData.path) {
                breakdownDiv.innerHTML = '<p style="color: #7f8c8d;">No critical path data available.</p>';
                return;
            }

            const criticalPath = visualizer.criticalPathData.path;
            const criticalPathTime = visualizer.criticalPathData.time;

            let html = '';

            // Critical Path Visualization
            html += '<div class="breakdown-section">';
            html += '<h4>Critical Path Details</h4>';
            html += '<p style="color: #7f8c8d; font-size: 0.9em; margin-bottom: 10px;">The longest path through the value stream, determining the minimum lead time</p>';

            // Process sequence
            html += '<div style="padding: 15px; background: #fff3cd; border-left: 4px solid #e67e22; margin-bottom: 15px;">';
            html += '<strong style="color: #e67e22;">Critical Path Sequence:</strong><br>';
            const pathNames = criticalPath.map(processId => {
                const process = visualizer.currentProcesses[processId];
                return process ? (process.attributes.name || processId) : processId;
            });
            html += '<span style="color: #2c3e50; font-family: monospace;">' + pathNames.join(' → ') + '</span>';
            html += '</div>';

            // Detailed breakdown
            let runningTotal = 0;

            criticalPath.forEach((processId, index) => {
                const process = visualizer.currentProcesses[processId];
                if (!process) return;

                const processName = process.attributes.name || processId;
                const pt = visualizer.convertTimeToStandardUnit(process.attributes.process_time);
                const wt = visualizer.convertTimeToStandardUnit(process.attributes.wait_time);
                const cycleTime = pt + wt;

                html += `<div class="breakdown-item">
                    <div class="breakdown-name">${index + 1}. ${processName} (CT)</div>
                    <div class="breakdown-value">${cycleTime.toFixed(4)}d</div>
                </div>`;

                runningTotal += cycleTime;

                // Add flow wait time if not the last process
                if (index < criticalPath.length - 1) {
                    const nextProcessId = criticalPath[index + 1];
                    const flow = visualizer.currentFlows.find(f => f.from === processId && f.to === nextProcessId);
                    if (flow) {
                        const flowWT = visualizer.convertTimeToStandardUnit(flow.wait_time);
                        html += `<div class="breakdown-item" style="padding-left: 20px; color: #7f8c8d;">
                            <div class="breakdown-name">   + Flow WT</div>
                            <div class="breakdown-value">${flowWT.toFixed(4)}d</div>
                        </div>`;
                        runningTotal += flowWT;
                    }
                }
            });

            html += '</div>';

            // Total section
            html += '<div class="breakdown-total">';
            html += '<div class="breakdown-name">Critical Path Time</div>';
            html += `<div class="breakdown-value">${criticalPathTime.toFixed(4)}d</div>`;
            html += '</div>';

            // Show formula
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em; color: #7f8c8d;">';
            html += '<strong>Formula:</strong> Critical Path = Sum of (Cycle Times + Flow Wait Times) along the longest path<br>';
            html += '<strong>Where:</strong> Cycle Time (CT) = Process Time (PT) + Process Wait Time (WT)';
            html += '</div>';

            breakdownDiv.innerHTML = html;
        }

        // Make functions globally available
        window.parser = parser;
        window.saveVSM = saveVSM;
        window.parseAndVisualize = parseAndVisualize;
        window.addNewProcess = addNewProcess;
        window.saveVSMToFile = saveVSMToFile;
        window.loadVSMFromFile = loadVSMFromFile;

        // Initialize pane splitter
        function initializePaneSplitter() {
            const splitter = document.getElementById('paneSplitter');
            const editorPanel = document.querySelector('.editor-panel');
            const mainContent = document.querySelector('.main-content');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            splitter.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = editorPanel.offsetWidth;
                splitter.classList.add('active');
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'col-resize';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                const newWidth = Math.max(200, Math.min(startWidth + deltaX, mainContent.offsetWidth * 0.8));
                editorPanel.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    splitter.classList.remove('active');
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            });
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeVSM();
                initializePaneSplitter();
            });
        } else {
            initializeVSM();
            initializePaneSplitter();
        }
    </script>
</body>
</html>